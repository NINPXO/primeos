# Features Module - Complete Feature Implementations

**Purpose**: Each feature is a self-contained module with domain/data/presentation layers

## Feature List (7 modules)

| Module | Purpose | Tables | Use Cases |
|--------|---------|--------|-----------|
| goals | Create/track goals with categories | goal_categories, goals | 8 |
| progress | Track goal progress numerically | progress_entries | 7 |
| daily_log | Log daily activities auto-linked to changes | daily_log_categories, daily_log_entries | 5 |
| notes | Rich text notes with tags | notes, note_tags, notes_tags_junction | 7 |
| dashboard | Aggregate summaries and quick actions | — (queries all others) | 5 |
| search | FTS5 cross-module search | fts_search | 3 |
| trash | Unified soft-deleted item recovery | — (queries is_deleted) | 6 |

## Architecture Pattern (All Modules Follow)

```
feature/
├── data/
│   ├── datasources/
│   │   └── {feature}_local_datasource.dart
│   │       ├── Raw SQL queries
│   │       ├── FTS maintenance
│   │       └── CRUD operations
│   ├── models/
│   │   ├── {entity}_model.dart (extends entity)
│   │   └── {related}_model.dart
│   └── repositories/
│       └── {feature}_repository_impl.dart
│           ├── Maps datasource → domain
│           └── Converts exceptions to AppResult<T>
│
├── domain/
│   ├── entities/
│   │   ├── {entity}.dart (pure Dart, Freezed)
│   │   └── {related}.dart
│   ├── repositories/
│   │   └── {feature}_repository.dart (abstract)
│   └── usecases/
│       ├── get_{entity}.dart
│       ├── create_{entity}.dart
│       ├── update_{entity}.dart
│       ├── delete_{entity}.dart
│       └── {custom_operation}.dart
│
└── presentation/
    ├── providers/
    │   └── {feature}_provider.dart
    │       ├── AsyncNotifierProvider or StateNotifierProvider
    │       ├── Watches datasource/repository
    │       └── Actions: add, update, delete, refresh
    ├── screens/
    │   ├── {feature}_screen.dart (main list view)
    │   ├── {feature}_form_screen.dart (create/edit)
    │   └── {feature}_detail_screen.dart (optional)
    └── widgets/
        ├── {feature}_card.dart (list item)
        ├── {feature}_status_badge.dart (status indicator)
        └── {custom}_widget.dart
```

## Development Workflow

**1. Start with Domain** (contracts):
```dart
// domain/entities/my_entity.dart
@freezed
class MyEntity with _$MyEntity {
  const factory MyEntity({
    required String id,
    required String title,
    required DateTime createdAt,
  }) = _MyEntity;
}

// domain/repositories/my_repository.dart
abstract class MyRepository {
  Future<AppResult<MyEntity>> getById(String id);
  Future<AppResult<void>> create(MyEntity entity);
}
```

**2. Implement Data** (database):
```dart
// data/datasources/my_local_datasource.dart
class MyLocalDataSource {
  Future<MyEntity> getById(String id) async {
    final result = await database.query(...);
    return MyModel.fromMap(result.first).toEntity();
  }
}

// data/repositories/my_repository_impl.dart
class MyRepositoryImpl implements MyRepository {
  @override
  Future<AppResult<MyEntity>> getById(String id) async {
    try {
      final entity = await datasource.getById(id);
      return AppResult.success(entity);
    } catch (e) {
      return AppResult.error(DatabaseFailure(...));
    }
  }
}
```

**3. Define Use Cases** (logic):
```dart
// domain/usecases/get_my_entity.dart
class GetMyEntity {
  final MyRepository repository;
  GetMyEntity(this.repository);
  Future<AppResult<MyEntity>> call(String id) => repository.getById(id);
}
```

**4. Connect Riverpod** (state):
```dart
// presentation/providers/my_provider.dart
final myRepositoryProvider = FutureProvider((ref) async {
  final db = await ref.watch(databaseProvider.future);
  final datasource = MyLocalDataSource(database: db);
  return MyRepositoryImpl(datasource: datasource);
});

final myEntityProvider = FutureProvider.family((ref, id) async {
  final repo = await ref.watch(myRepositoryProvider.future);
  final result = await repo.getById(id);
  return result.maybeMap(success: (_) => _.data, orElse: () => null);
});
```

**5. Build UI** (screens):
```dart
// presentation/screens/my_screen.dart
class MyScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final entity = ref.watch(myEntityProvider('123'));
    return entity.when(
      loading: () => LoadingOverlay(),
      error: (e, st) => ErrorStateWidget(error: '$e'),
      data: (entity) => entity == null
        ? EmptyStateWidget(...)
        : MyCard(entity),
    );
  }
}
```

## Quick Checklist for New Feature

- [ ] Create entities (Freezed @freezed)
- [ ] Create repository interface (abstract)
- [ ] Create datasource (raw SQL)
- [ ] Create repository impl (error handling)
- [ ] Create models (extend entities)
- [ ] Create use cases (one per action)
- [ ] Create Riverpod providers (FutureProvider)
- [ ] Create screens (use AsyncValue.when)
- [ ] Create widgets (reusable, <200 lines)
- [ ] Add routes in app_router.dart
- [ ] Update FTS index if searchable
- [ ] Test CRUD cycle
- [ ] Test error states

## Common Mistakes

❌ **Business logic in screens**
- Hard to test, violates clean architecture

✅ **Put logic in use cases**, screens only call `ref.watch()`

❌ **Throwing exceptions from repositories**
- Breaks error handling pattern

✅ **Return AppResult<T>** with success/error

❌ **Forgetting to update FTS**
- Search doesn't find new content

✅ **Call updateFtsIndex()** in datasource after writes

❌ **Not handling all AsyncValue states**
- Screen crashes or freezes

✅ **Use .when(loading:, error:, data:)** for all AsyncValues

---

**Module-specific details**: Check `.claude.md` in each feature folder!
