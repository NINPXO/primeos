# Notes Module - Rich Text & Tagging

**Purpose**: Create rich text notes with tag-based organization

**Key Tables**: `notes`, `note_tags`, `notes_tags_junction`

## Quick Understanding

**Note Entity**:
```dart
Note {
  id: UUID,
  title: "Meeting notes 2026-02-18",
  contentJson: "{delta format from flutter_quill}",
  contentPlain: "Plain text for search",
  tags: ["meeting", "project-x"],
  isArchived: 0 | 1,  // Archive != soft delete
  timestamps,
  is_deleted: 0 | 1,  // Soft delete
}
```

**Key Difference**:
- `is_archived=1`: Hidden from list, but not deleted
- `is_deleted=1`: In trash, recoverable
- Can be both archived AND deleted

**NoteTag Entity**:
```dart
NoteTag {
  id: UUID,
  name: "project-x",
  color_hex: "#FF5733",
  timestamps,
  is_deleted
}
```

## File Structure

```
data/datasources/notes_local_datasource.dart
  - getAll() / getArchived() / getDeleted()
  - create(note) + FTS + junction inserts
  - update(note) + FTS + junction updates
  - archive(id) / unarchive(id)
  - softDelete(id) / restore(id) / hardDelete(id)
  - Tag ops (create, update, delete)
  - getTags() / getTagsForNote(noteId)
  - bulkTag(noteIds, tagId) / bulkUntag(...)

domain/entities/note.dart, note_tag.dart

domain/usecases/
  - get_all_notes.dart
  - search_notes.dart
  - create_note.dart
  - update_note.dart
  - archive_note.dart
  - soft_delete_note.dart (→ trash)
  - export_notes_by_tag.dart
  - manage_note_tags.dart

presentation/providers/notes_provider.dart
  - Watch: all notes (filter archived/deleted)
  - Watch: tags
  - Actions: create, update, archive, delete

presentation/screens/
  - notes_screen.dart (tag filter chips, list)
  - note_editor_screen.dart (QuillEditor + QuillToolbar)

presentation/widgets/
  - note_card.dart (preview, tags, archive icon)
  - note_tag_filter.dart (multi-select chips)
  - tag_editor_chip.dart (add/remove tags)
```

## Rich Text with Flutter Quill

**contentJson Format**:
```json
{
  "ops": [
    {"insert": "Hello "},
    {"insert": "world", "attributes": {"bold": true}},
    {"insert": "\n"}
  ]
}
```

**contentPlain Format**:
```
Plain text version for FTS search (no formatting)
```

**Keep Both in Sync**:
```dart
// When saving note from editor
final quillDocument = QuillDocument.fromJson(contentJson);
final plainText = quillDocument.toPlainText();

await datasource.create(Note(
  contentJson: jsonEncode(contentJson),
  contentPlain: plainText,
  // ...
));
```

## Tag Many-to-Many Pattern

**Create note with tags**:
```dart
// Insert note
final noteId = await datasource.create(note);

// Insert junction records
for (final tagId in note.tags) {
  await database.insert('notes_tags_junction', {
    'note_id': noteId,
    'tag_id': tagId,
  });
}
```

**Update note tags**:
```dart
// Delete old junctions
await database.delete(
  'notes_tags_junction',
  where: 'note_id = ?',
  whereArgs: [noteId],
);

// Insert new junctions
for (final tagId in updatedTags) {
  await database.insert('notes_tags_junction', {...});
}
```

**Query notes with tags**:
```dart
final result = await database.rawQuery('''
  SELECT DISTINCT n.*
  FROM notes n
  LEFT JOIN notes_tags_junction ntj ON n.id = ntj.note_id
  LEFT JOIN note_tags nt ON ntj.tag_id = nt.id
  WHERE n.is_deleted = 0
    AND (nt.name LIKE ? OR n.title LIKE ?)
  ORDER BY n.created_at DESC
''', ['%search%', '%search%']);
```

## FTS Index for Search

```dart
// When note content changes
await database.insert(
  'fts_search',
  {
    'source_type': 'note',
    'source_id': noteId,
    'title': note.title,
    'body': note.contentPlain,  // Use plain text, not JSON
  },
  conflictAlgorithm: ConflictAlgorithm.replace,
);
```

## Archive vs Delete

**Archive** (hide from main list):
```dart
await datasource.archive(noteId);
// Sets is_archived=1, archived_at=timestamp
// NOT in trash, just hidden
// Can be restored with unarchive()
```

**Soft Delete** (move to trash):
```dart
await datasource.softDelete(noteId);
// Sets is_deleted=1, deleted_at=timestamp
// Appears in trash, recoverable
```

**Hard Delete** (permanent):
```dart
await datasource.hardDelete(noteId);
// DELETE FROM notes WHERE id = ?
// Permanent, unrecoverable
```

## Testing Checklist

- [ ] Create note with rich text formatting
- [ ] contentJson and contentPlain both saved
- [ ] Create 2+ tags, associate with note
- [ ] Update tags for note, junctions updated
- [ ] Archive note, hidden from main list
- [ ] Unarchive note, back in main list
- [ ] Soft delete note, appears in trash
- [ ] Restore from trash
- [ ] Hard delete, permanently gone
- [ ] Tag filter chips work (multi-select)
- [ ] Search finds note by title and content
- [ ] QuillEditor displays formatting on load
- [ ] QuillToolbar buttons work (bold, italic, link, etc)
- [ ] Export to CSV, tags pipe-separated

## Common Mistakes

❌ **Only saving contentJson**
- FTS search finds nothing
- Plain text rendering shows raw JSON

✅ **Always save both**: contentJson + contentPlain

❌ **Forgetting to delete old junctions on tag update**
- Duplicate tag associations
- Queries return wrong tags

✅ **Delete, then insert** for tag updates

❌ **Mixed archive/delete states**
- confusing which notes to display

✅ **Clear: archive for hide, delete for trash**

## Dependencies

- `core/database`
- `core/types`
- `core/constants`
- `flutter_quill` (external package)

**Used By**: dashboard (note count), search (FTS), trash (deleted notes)

---

**Remember**: Keep contentJson and contentPlain in sync!
