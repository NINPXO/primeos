# Search Module - Cross-Module FTS

**Purpose**: Full-text search across all 4 modules (Goals, Progress, DailyLog, Notes)

**Key Table**: `fts_search` (virtual table, FTS5)

## Quick Understanding

**FTS5 Virtual Table**:
```
fts_search {
  source_type: "goal" | "progress" | "daily_log" | "note",
  source_id: UUID,
  title: "Learn Rust",
  body: "Content for searching",
}
```

**Search Flow**:
1. User types in search field
2. Debounce 300ms
3. Query: `fts_search MATCH 'query*'` (prefix match)
4. Fetch detailed data (category names, tags, etc.)
5. Return SearchResult sealed union
6. Display grouped by type

## SearchResult Sealed Union

```dart
@freezed
class SearchResult {
  const factory SearchResult.goalResult({...}) = GoalResult;
  const factory SearchResult.progressResult({...}) = ProgressResult;
  const factory SearchResult.dailyLogResult({...}) = DailyLogResult;
  const factory SearchResult.noteResult({...}) = NoteResult;
  
  String get sourceType => map(
    goalResult: (_) => 'Goal',
    progressResult: (_) => 'Progress',
    // ...
  );
}
```

**Benefits**:
- Type-safe: compiler ensures all variants handled
- Pattern matching: `.map()` on result type
- Deep linking: `result.deepLinkRoute` navigates to source

## File Structure

```
data/datasources/search_local_datasource.dart
  - searchAll(query) → List<SearchResultModel>
  - Fetches FTS results
  - Calls _getDetailedResult for each
  - Joins with original tables for full data

domain/entities/search_result.dart
  - Sealed union with 4 variants
  - sourceType getter
  - deepLinkRoute getter

domain/repositories/search_repository.dart
  - search(query) → AppResult<List<SearchResult>>
  - getSearchHistory(), saveSearchHistory(), clearSearchHistory()

domain/usecases/
  - search_all.dart
  - get_search_history.dart (TODO)
  - save_search_history.dart (TODO)
  - clear_search_history.dart (TODO)

presentation/providers/search_provider.dart
  - searchQueryProvider: StateNotifierProvider<String>
  - searchResultsProvider: FutureProvider with 300ms debounce
  - searchResultsGroupedProvider: grouped by type

presentation/screens/global_search_screen.dart
  - AutoFocus TextField
  - Results grouped by type with counts
  - Deep link on tap

presentation/widgets/
  - search_result_card.dart (type icon, badges, metadata)
  - search_result_section_header.dart (type name + count)
  - search_delegate.dart (SearchDelegate for in-app search)
```

## Maintaining FTS Index

**Every datasource must maintain FTS**:

When creating:
```dart
await database.insert('notes', noteData);
await database.insert('fts_search', {
  'source_type': 'note',
  'source_id': noteId,
  'title': note.title,
  'body': note.contentPlain,
});
```

When updating:
```dart
await database.update('notes', updatedData, ...);
// Replace FTS entry (same ID)
await database.insert('fts_search', {
  'source_type': 'note',
  'source_id': noteId,
  'title': note.title,
  'body': note.contentPlain,
}, conflictAlgorithm: ConflictAlgorithm.replace);
```

When soft-deleting:
```dart
await database.update('notes', {'is_deleted': 1}, ...);
// Remove from FTS
await database.delete('fts_search',
  where: 'source_id = ? AND source_type = ?',
  whereArgs: [noteId, 'note'],
);
```

## Adding New Module to Search

Example: Add "Budget" module

1. **Add FTS data in datasource**:
   ```dart
   // In budget_local_datasource.dart create()
   await database.insert('fts_search', {
     'source_type': 'budget',
     'source_id': budgetId,
     'title': budget.name,
     'body': budget.category,
   });
   ```

2. **Add SearchResult variant**:
   ```dart
   @freezed
   class SearchResult {
     // ... existing
     const factory SearchResult.budgetResult({...}) = BudgetResult;
     // Add case in sourceType/deepLinkRoute getters
   }
   ```

3. **Update datasource**:
   ```dart
   // In search_local_datasource.dart _getDetailedResult()
   case 'budget':
     return _getBudgetDetail(sourceId);
   ```

4. **Test search**:
   ```bash
   # Search for budget by name/category
   # Verify grouped result displays correctly
   # Verify deep link works
   ```

## Debounce Pattern

```dart
final searchResultsProvider =
    FutureProvider.autoDispose<List<SearchResult>>((ref) async {
  final query = ref.watch(searchQueryProvider);
  
  if (query.isEmpty) return [];
  
  // Debounce: delay before search
  await Future.delayed(const Duration(milliseconds: 300));
  
  // Perform FTS query
  final result = await useCase(query);
  return result.maybeMap(success: (_) => _.data, orElse: () => []);
});
```

**Benefits**:
- Avoids 10 queries while user types "hello"
- Only 1 query after user stops typing for 300ms
- Cancels if user types again before delay ends

## Search Results Display

**Grouped by type**:
```
Goal (3)
  ├─ Learn Rust
  ├─ Exercise 5x/week
  └─ Read 2 books

Progress (5)
  ├─ 42 pages
  ├─ 5km run
  └─ ...

Daily Log (2)
  ├─ Completed workout
  └─ ...

Note (8)
  ├─ Meeting notes
  └─ ...
```

**Implementation**:
```dart
// In presentation/screens/global_search_screen.dart
final grouped = <String, List<SearchResult>>{};
for (final result in results) {
  grouped.putIfAbsent(result.sourceType, () => []).add(result);
}

// Build list with headers + cards
```

## Testing Checklist

- [ ] Search finds goal by title
- [ ] Search finds progress by value/note
- [ ] Search finds daily log by title
- [ ] Search finds note by title/content
- [ ] Results grouped by type
- [ ] Tap result navigates to source screen
- [ ] Empty search shows no results
- [ ] Debounce works (type fast, only 1 query)
- [ ] FTS index maintained after CRUD
- [ ] Search finds nothing after delete (FTS cleaned up)
- [ ] Search case-insensitive
- [ ] Prefix match works ("rust" finds "Rust Book")

## Dependencies

- `core/database`
- `core/types`
- `all feature modules` (queries their tables)

**Used By**: GlobalSearchScreen route, SearchDelegate for in-app search

---

**Critical**: Every CRUD operation must maintain FTS index!
