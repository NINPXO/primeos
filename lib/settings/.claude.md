# Settings Module - App Configuration

**Purpose**: Persist app settings (theme mode, user preferences)

**Key Table**: `app_settings` (key-value store)

## Quick Understanding

**AppSettings Entity**:
```dart
AppSettingsEntity {
  themeMode: "light" | "dark" | "system",
  dbVersion: "1",  // For schema versioning
  updatedAt: DateTime,
}
```

**Stored in SQLite** (app_settings table):
```sql
INSERT INTO app_settings (key, value, updated_at)
VALUES ('theme_mode', 'dark', '2026-02-18T10:30:00Z');
VALUES ('db_version', '1', '2026-02-18T10:30:00Z');
```

## File Structure

```
data/datasources/settings_local_datasource.dart
  - getSettings() → AppSettingsModel (fetch all)
  - getSetting(key) → String? (single value)
  - updateSetting(key, value) → void
  - getThemeMode() → String (convenience)
  - setThemeMode(mode) → void (convenience)

domain/entities/app_settings.dart
  - Freezed immutable

domain/repositories/settings_repository.dart
  - Abstract interface

domain/usecases/
  - get_app_settings.dart
  - update_theme_mode.dart

presentation/providers/settings_provider.dart
  - appSettingsProvider: FutureProvider
  - themeModeProvider: StateNotifierProvider (CRITICAL)
    * Watches database + local state
    * Calls setThemeMode use case on update
    * Persists to app_settings

presentation/screens/settings_screen.dart
  - Theme selector (Light/Dark/System)
  - Data management section (stubs for import/export/backup)
  - Trash link
  - About dialog
```

## Theme Persistence Flow

**1. App starts**:
```dart
// In app.dart
final themeModeAsync = ref.watch(themeModeProvider);
themeModeAsync.when(
  data: (themeMode) => MaterialApp.router(
    themeMode: themeMode,  ← Applied to MaterialApp
    ...
  ),
)
```

**2. User selects theme in SettingsScreen**:
```dart
ElevatedButton(
  onPressed: () {
    ref.read(themeModeProvider.notifier)
      .setThemeMode(ThemeMode.dark);
  },
  child: Text('Dark Mode'),
)
```

**3. ThemeModeNotifier persists**:
```dart
class ThemeModeNotifier extends StateNotifier<ThemeMode> {
  Future<void> setThemeMode(ThemeMode mode) async {
    state = mode;  // Update local state immediately
    // Then persist to DB asynchronously
    await updateThemeModeUseCase(_themeModeToString(mode));
  }
}
```

**4. Database updated**:
```dart
// updateThemeModeUseCase calls
await repository.setThemeMode('dark');  // Updates app_settings table
```

**5. App rebuilds** with new theme (because provider state changed)

## Adding a New Setting

Example: Add `fontSize` preference

1. **Add key-value in database** (seed in migration_v1.dart):
   ```sql
   INSERT INTO app_settings (key, value, updated_at)
   VALUES ('font_size', 'medium', '...');
   ```

2. **Update entity**:
   ```dart
   @freezed
   class AppSettingsEntity {
     const factory AppSettingsEntity({
       required String fontSize,  // Add this
     }) = _AppSettingsEntity;
   }
   ```

3. **Add datasource method**:
   ```dart
   Future<String> getFontSize() async {
     final result = await getSetting('font_size');
     return result ?? 'medium';
   }
   
   Future<void> setFontSize(String size) async {
     await updateSetting('font_size', size);
   }
   ```

4. **Add use case**:
   ```dart
   class UpdateFontSize {
     final SettingsRepository repository;
     Future<AppResult<void>> call(String size) {
       return repository.setFontSize(size);
     }
   }
   ```

5. **Add to provider**:
   ```dart
   final fontSizeProvider = StateNotifierProvider<FontSizeNotifier, String>((ref) async {
     final settings = await ref.watch(appSettingsProvider.future);
     return FontSizeNotifier(fontSize: settings.fontSize);
   });
   ```

6. **Add UI in SettingsScreen**:
   ```dart
   SegmentedButton<String>(
     segments: [...],
     selected: {ref.watch(fontSizeProvider)},
     onSelectionChanged: (selected) {
       ref.read(fontSizeProvider.notifier).setFontSize(selected.first);
     },
   )
   ```

## Testing Checklist

- [ ] App starts with persisted theme from last session
- [ ] Change theme, verified in app_settings table
- [ ] Restart app, theme persists
- [ ] Light/Dark/System all work
- [ ] All screens respect theme change immediately
- [ ] Settings screen displays current theme selection
- [ ] Get app_settings query returns all key-values
- [ ] Update single setting, others unchanged

## Common Patterns

**Fetch all settings**:
```dart
final settings = await datasource.getSettings();
// Returns AppSettingsModel with themeMode, dbVersion, etc.
```

**Update one setting without affecting others**:
```dart
await datasource.updateSetting('theme_mode', 'dark');
// Only updates this key in app_settings
```

**Use provider to watch settings**:
```dart
final settings = ref.watch(appSettingsProvider);
settings.whenData((s) {
  print('Theme: ${s.themeMode}');
});
```

## Dependencies

- `core/database`
- `core/types`
- `core/constants`

**Used By**: app.dart (theme), SettingsScreen (UI)

## Limitations (TODOs)

- Search history: Interface defined, persistence not implemented
- Backup/Import UI: Button stubs, file picker integration pending

---

**Remember**: Always use provider pattern for reactive UI updates!
