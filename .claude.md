# PrimeOS - Flutter Personal Life Tracker

**Status**: Complete (11/11 phases), ready for production
**Stack**: Flutter 3.19+, Dart, Riverpod, SQLite (sqflite), Material 3
**Team**: Solo developer (you)
**Phase**: Maintenance / Enhancement ready

## Quick Context

**What is this?**: Offline-first Flutter app for tracking goals, progress, daily logs, and notes locally on-device.

**Architecture**: Clean (presentation/domain/data) + Riverpod state + GoRouter navigation

**Database**: SQLite with FTS5, 9 tables, soft delete pattern, UUID PKs

## Critical Files (Know These!)

```
lib/core/database/app_database.dart      ← Singleton, migrations
lib/core/router/app_router.dart          ← Navigation config (5 tabs)
lib/core/constants/db_constants.dart     ← Table/column names (centralized)
lib/settings/presentation/providers/     ← Theme persistence entry point
```

## Module Organization

Each feature (`lib/features/{module}/`) follows:
```
├── data/
│   ├── datasources/        ← Raw SQL + FTS maintenance
│   ├── models/             ← Freezed, extends entities
│   └── repositories/       ← Error mapping to AppResult<T>
├── domain/
│   ├── entities/           ← Pure Dart (no Flutter)
│   ├── repositories/       ← Abstract interfaces
│   └── usecases/           ← One-method classes
└── presentation/
    ├── providers/          ← Riverpod AsyncNotifierProvider
    ├── screens/            ← Pages/routes
    └── widgets/            ← Reusable UI components
```

## Common Patterns

**State Management**:
```dart
// Datasource → Repository (error handling) → UseCase → Provider
// Provider watches database FutureProvider + local state
ref.watch(databaseProvider).whenData((db) => ...)
```

**Database Operations**:
```dart
// Always use datasource for SQL
// Maintain FTS index on writes/deletes
await database.insert(...);
await localDataSource.updateFtsIndex(id, updatedText);
```

**Error Handling**:
```dart
// Return AppResult<T> (success/error sealed class)
// Never throw exceptions from repositories
try {
  final data = await datasource.getData();
  return AppResult.success(data);
} catch (e) {
  return AppResult.error(DatabaseFailure(message: e.toString()));
}
```

## Module Dependencies

```
features/goals ────────→ core (database, router, types)
features/progress ─────→ goals + core
features/daily_log ────→ goals, progress + core (auto-logging on changes)
features/notes ────────→ core (tags, FTS index)
features/dashboard ────→ goals, progress, daily_log, notes (aggregates)
features/search ───────→ all modules (FTS across all)
features/trash ────────→ all modules (queries soft-deleted items)
settings ──────────────→ core (theme persistence)
```

## Key Decisions Made

1. **Soft Delete**: `is_deleted=1, deleted_at=timestamp` — recoverable deletion
2. **FTS5 Maintenance**: Application-layer triggers in datasources, not DB triggers
3. **Category Denormalization**: `progress.category_id` copied from `goals.category_id` for fast filtering
4. **UUID PKs**: All PKs are `TEXT` (not SQLite rowid) — stable for CSV import/export
5. **Auto-Logging**: Goal/progress changes auto-create daily_log_entry in use case layer
6. **Theme Persistence**: Via `app_settings` table, watched by Riverpod provider

## When Modifying a Module

1. **Understand the data flow**: Datasource → Model → Repository → UseCase → Provider → Screen
2. **Maintain FTS index**: If adding searchable content, update `fts_search` table
3. **Handle null cases**: Use `?.` and `??` to avoid null crashes
4. **Test CRUD cycle**: Create → Read → Update → SoftDelete → Restore → HardDelete
5. **Check imports**: Use `db_constants.dart` for table/column names (not magic strings)

## File Locations Quick Ref

| What | Where |
|------|-------|
| Table/column names | `lib/core/constants/db_constants.dart` |
| SQL schema | `lib/core/database/migrations/migration_v1.dart` |
| Routes | `lib/core/router/app_router.dart` |
| Validators | `lib/core/utils/form_validators.dart` |
| AppResult type | `lib/core/types/app_result.dart` |
| Theme provider | `lib/settings/presentation/providers/settings_provider.dart` |
| Shared widgets | `lib/shared/widgets/` |

## Testing Checklist

After modifying any module:
- [ ] Syntax: `flutter analyze` (zero warnings)
- [ ] Import: Check `db_constants` usage, no magic strings
- [ ] CRUD: Create → read → update → soft delete → restore → hard delete
- [ ] FTS: New searchable content added to `fts_search` table?
- [ ] Error: AsyncValue handles `loading`/`error`/`data` states
- [ ] Theme: Test in both light and dark mode
- [ ] Empty: List screen shows EmptyStateWidget when no items

## Common Tasks

**Add new searchable field to a module**:
1. Add column to table in `migration_v1.dart`
2. Update datasource FTS indexing
3. Update model to include field
4. Update entity in domain layer
5. Test: Search should find the new field

**Add new setting**:
1. Insert row in `app_settings` with key/value
2. Add getter in `settings_local_datasource.dart`
3. Create use case in `domain/usecases/`
4. Add provider in `presentation/providers/`
5. Wire to UI in settings screen

**Add new screen**:
1. Create in `presentation/screens/{name}_screen.dart`
2. Add route in `lib/core/router/app_router.dart`
3. Use `ref.watch(provider)` for data/state
4. Handle loading/error/data states
5. Test empty and error cases

## Resources

- GitHub: https://github.com/NINPXO/primeos
- Docs: See `DEVELOPMENT.md` for full project summary
- Memory: `.claude/memory/MEMORY.md` tracks session progress

---

**For module-specific details, see `.claude.md` in each feature folder.**
